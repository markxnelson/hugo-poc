[
{
	"uri": "/weblogic-kubernetes-operator/userguide/managing-domains/ingress/nodeports/",
	"title": "Nodeports",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/weblogic-kubernetes-operator/samples/simple/credentials/",
	"title": "Credentials",
	"tags": [],
	"description": "",
	"content": " Chapter 1 Credentials Lorem Ipsum.\n"
},
{
	"uri": "/weblogic-kubernetes-operator/developerguide/requirements/",
	"title": "Requirements",
	"tags": [],
	"description": "",
	"content": " In addition to the requirements listed in the User Guide, the following software is also required to obtain and build the operator:\n Git (1.8 or later recommended) Java Developer Kit (1.8u131 or later recommended; please use 1.8, tests will not work on 1.9 or later versions) Apache Maven (3.3 or later recommended)  The operator is written primarily in Java, BASH shell scripts, and WLST scripts. The Java code uses features introduced in Java 1.8 \u0026ndash; for example, closures \u0026ndash; but does not use any Java 1.9 features.\nBecause the target runtime environment for the operator is Oracle Linux, no particular effort has been made to ensure the build or tests run on any other operating system. Please be aware that Oracle will not provide support, or accept pull requests to add support, for other operating systems.\nObtaining the operator source code The operator source code is published on GitHub at https://github.com/oracle/weblogic-kubernetes-operator. Developers may clone this repository to a local machine or, if desired, create a fork in their personal namespace and clone the fork. Developers who are planning to submit a pull request are advised to create a fork.\nTo clone the repository from GitHub, issue this command:\n$ git clone https://github.com/oracle/weblogic-kubernetes-operator.git  "
},
{
	"uri": "/weblogic-kubernetes-operator/security/rbac/",
	"title": "RBAC",
	"tags": [],
	"description": "",
	"content": " The operator assumes that certain roles and role bindings are created on the Kubernetes cluster. The operator installation scripts create these, and the operator verifies that they are correct when the cluster starts up. This document lists the RBAC definitions that are created.\nThe general design goal is to provide the operator with the minimum amount of permissions that it requires, and to favor built-in roles over custom roles, where it make sense to do so.\nKubernetes role definitions    Cluster role Resources Verbs Notes     NAMESPACE-weblogic-operator-clusterrole-general namespaces, persistentvolumes get, list, watch 1    customresourcedefinitions in API group apiextensions.k8s.io get, list, watch, create, update, patch, delete, deletecollection     domains in API group weblogic.oracle get, list, watch, update, patch     Ingresses in API group extensions get, list, watch, create, update, patch, delete, deletecollection    NAMESPACE-weblogic-operator-clusterrole-nonresource nonResourceURLs: [\u0026ldquo;/version/*\u0026ldquo;] get 1   NAMESPACE-weblogic-operator-clusterrole-namespace secrets, persistentvolumeclaims get, list, watch 2    services, pods, networkpolicies get, list, watch, create, update, patch, delete, deletecollection    NAMESPACE-weblogic-operator-clusterrolebinding-discovery system:discovery in API group rbac.authorization.k8s.io  1   NAMESPACE-weblogic-operator-clusterrolebinding-auth-delegator system:auth-delegator in API group rbac.authorization.k8s.io  1    Notes:\n This cluster role is assigned to the operator’s service account in the operator’s namespace. The uppercase text NAMESPACE in the cluster role name is replaced with the operator’s namespace. This cluster role is assigned to the operator’s service account in each of the “target namespaces”; that is, each namespace that the operator is configured to manage.  "
},
{
	"uri": "/weblogic-kubernetes-operator/samples/simple/",
	"title": "Simple",
	"tags": [],
	"description": "",
	"content": " Chapter 1 Simple Samples This section provides details about simple samples for individual tasks. The samples in this section are intended to be modified before production use.\n"
},
{
	"uri": "/weblogic-kubernetes-operator/userguide/managing-operators/using-the-operator/using-kubectl/",
	"title": "Using kubectl",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/weblogic-kubernetes-operator/userguide/managing-domains/domain-lifecycle/startup/",
	"title": "Startup",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/weblogic-kubernetes-operator/userguide/managing-domains/integrations/exporting-metrics/metrics-exporter/",
	"title": "Metrics Exporter",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/weblogic-kubernetes-operator/userguide/managing-operators/installation/",
	"title": "Installation",
	"tags": [],
	"description": "",
	"content": " Chapter 1 Installation Lorem Ipsum.\n"
},
{
	"uri": "/weblogic-kubernetes-operator/userguide/managing-domains/integrations/exporting-metrics/",
	"title": "Exporting Metrics",
	"tags": [],
	"description": "",
	"content": " Chapter 1 Exporting Metrics Lorem Ipsum.\n"
},
{
	"uri": "/weblogic-kubernetes-operator/userguide/managing-domains/domain-in-image/base-images/",
	"title": "Base Images",
	"tags": [],
	"description": "",
	"content": " Chapter 1 Base Images Lorem Ipsum.\n"
},
{
	"uri": "/weblogic-kubernetes-operator/userguide/managing-domains/choosing-a-model/",
	"title": "Choosing a Model",
	"tags": [],
	"description": "",
	"content": " Chapter 1 Choosing a model Lorem Ipsum.\n"
},
{
	"uri": "/weblogic-kubernetes-operator/userguide/introduction/introduction/",
	"title": "Getting Started",
	"tags": [],
	"description": "",
	"content": " An operator is an application-specific controller that extends Kubernetes to create, configure, and manage instances of complex applications. The Oracle WebLogic Server Kubernetes Operator follows the standard Kubernetes operator pattern, and simplifies the management and operation of WebLogic domains and deployments.\nYou can have one or more operators in your Kubernetes cluster that manage one or more WebLogic domains each. We provide a Helm chart to manage the installation and configuration of the operator. Detailed instructions are available here.\nPrerequisites  Kubernetes 1.10.11+, 1.11.5+, and 1.12.3+ (check with kubectl version). Flannel networking v0.9.1-amd64 (check with docker images | grep flannel). Docker 18.03.1.ce (check with docker version). Helm 2.8.2+ (check with helm version). Oracle WebLogic Server 12.2.1.3.0 with patch 29135930.  The existing WebLogic Docker image, store/oracle/weblogic:12.2.1.3, was updated on January 17, 2019, and has all the necessary patches applied. A docker pull is required if you pulled the image prior to that date.  You must have the cluster-admin role to install the operator.  Operator Docker image You can find the operator image in Docker Hub.\n"
},
{
	"uri": "/weblogic-kubernetes-operator/reference/javadoc/",
	"title": "Javadoc",
	"tags": [],
	"description": "",
	"content": "You can view the Java API documentation here.\n"
},
{
	"uri": "/weblogic-kubernetes-operator/faq/samplepage/",
	"title": "Sample Page",
	"tags": [],
	"description": "",
	"content": " Here is some neat stuff we can do We can draw decision diagrams:\ngraph LR;\rA[Install Operator] --|Now decide| C{Domain Type}\rC --|Persistent| D[Create persistent domain]\rC --|Domain in Image| E[Create domain image]\r\rAnd some more And have expanding more detail thingies\n\r\rLike this\r\r\rLorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n\r And also this   "
},
{
	"uri": "/weblogic-kubernetes-operator/quickstart/introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "Use this Quick Start guide to create a WebLogic deployment in a Kubernetes cluster with the Oracle WebLogic Kubernetes Operator. Please note that this walk-through is for demonstration purposes only, not for use in production. These instructions assume that you are already familiar with Kubernetes. If you need more detailed instructions, please refer to the User guide.\nIf you have an older version of the operator installed on your cluster, you must remove it before installing this version. This includes the 2.0-rc1 version; it must be completely removed. You should remove the deployment (for example, kubectl delete deploy weblogic-operator -n your-namespace) and the custom resource definition (for example, kubectl delete crd domain). If you do not remove the custom resource definition you may see errors like this:\nError from server (BadRequest): error when creating \u0026quot;/scratch/output/uidomain/weblogic-domains/uidomain/domain.yaml\u0026quot;: the API version in the data (weblogic.oracle/v2) does not match the expected API version (weblogic.oracle/v1  \rYou should be able to upgrade from version 2.0-rc2 to 2.0 because there are no backward incompatible changes between these two releases.\n\r"
},
{
	"uri": "/weblogic-kubernetes-operator/quickstart/",
	"title": "Quick Start",
	"tags": [],
	"description": "",
	"content": " Quick Start This section provides a simple tutorial to get you up an running quickly.\n"
},
{
	"uri": "/weblogic-kubernetes-operator/userguide/introduction/demo/",
	"title": "Demo",
	"tags": [],
	"description": "",
	"content": "This video provides a demonstration of the WebLogic Server Kubernetes Operator:\n  "
},
{
	"uri": "/weblogic-kubernetes-operator/userguide/managing-domains/ingress/ingress/",
	"title": "Ingress",
	"tags": [],
	"description": "",
	"content": " Ingresses are one approach provided by Kubernetes to configure load balancers. Depending on the version of Kubernetes you are using, and your cloud provider, you may need to use Ingresses. Please refer to the Ingress documentation for more information about Ingresses.\nWebLogic clusters as backends of an Ingress In an Ingress object, a list of backends are provided for each target that will be load balanced. Each backend is typically a Kubernetes service, more specifically, a combination of a serviceName and a servicePort.\nWhen the WebLogic operator creates a WebLogic domain, it also creates a service for each WebLogic cluster in the domain. The operator defines the service such that its selector will match all WebLogic server pods within the WebLogic cluster which are in the \u0026ldquo;ready\u0026rdquo; state.\nThe name of the service created for a WebLogic cluster follows the pattern \u0026lt;domainUID\u0026gt;-cluster-\u0026lt;clusterName\u0026gt;. For example, if the domainUID is domain1 and the cluster name is cluster-1, the corresponding service will be named domain1-cluster-cluster-1.\nThe service name must comply with standard Kubernetes rules for naming of objects and in particular with DNS-1035: \u0026gt; A DNS-1035 label must consist of lower case alphanumeric characters or \u0026lsquo;-\u0026rsquo;, start with an alphabetic character, and end with an alphanumeric character (e.g. \u0026lsquo;my-name\u0026rsquo;, or \u0026lsquo;abc-123\u0026rsquo;, regex used for validation is \u0026lsquo;a-z?\u0026lsquo;).\nTo comply with these requirements, if the domainUID or the cluster name contains some upper-case characters or underscores, then in the service name the upper-case characters will be converted to lower-case and underscores will be converted to hyphens. For example, if the domainUID is myDomain_1 and the cluster name is myCluster_1, the corresponding service will be named mydomain-1-cluster-mycluster-1.\nThe service, serviceName and servicePort, of a WebLogic cluster will be used in the routing rules defined in the Ingress object and the load balancer will route traffic to the WebLogic servers within the cluster based on the rules.\nNote: Most common Ingress controllers, for example Traefik, Voyager, and nginx, understand that there are zero or more actual pods behind the service, and they actually build their backend list and route requests to those backends directly, not through the service. This means that requests are properly balanced across the pods, according to the load balancing algorithm in use. Most Ingress controllers also subscribe to updates on the service and adjust their internal backend sets when additional pods become ready, or pods enter a non-ready state.\nSteps to set up an Ingress load balancer  Install the Ingress controller.  After the Ingress controller is running, it monitors Ingress resources in a given namespace(s) and acts accordingly.\n Create Ingress resource(s).  Ingress resources contain routing rules to one or more backends. An Ingress controller is responsible to apply the rules to the underlying load balancer. There are two approaches to create the Ingress resource:\na. Use the Helm chart ingress-per-domain.\nEach Ingress provider supports a number of annotations in Ingress resources. This Helm chart allows you to define the routing rules without dealing with the detailed provider-specific annotations. Currently we support two Ingress providers: Traefik and Voyager.\nb. Create the Ingress resource manually from a YAML file.\nManually create an Ingress YAML file and then apply it to the Kubernetes cluster.\nGuide and samples for Traefik and Voyager/HAProxy Traefik and Voyager/HAProxy are both popular Ingress controllers. Information about how to install and configure these to load balance WebLogic clusters is provided here: - Traefik guide - Voyager guide\nSamples are also provided for these two Ingress controllers, showing how to manage multiple WebLogic clusters as the backends, using different routing rules, host-routing and path-routing; and TLS termination: - Traefik samples - Voyager samples\n"
},
{
	"uri": "/weblogic-kubernetes-operator/userguide/managing-domains/accessing-the-domain/admin-console/",
	"title": "Admin Console",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/weblogic-kubernetes-operator/samples/simple/storage/",
	"title": "Storage",
	"tags": [],
	"description": "",
	"content": " Chapter 2 Storage Lorem Ipsum.\n"
},
{
	"uri": "/weblogic-kubernetes-operator/samples/production/",
	"title": "Production",
	"tags": [],
	"description": "",
	"content": " Chapter 2 Production Samples The samples in this section are intended to help you create a production deployment of WebLogic on Kubernetes.\n"
},
{
	"uri": "/weblogic-kubernetes-operator/userguide/managing-operators/using-the-operator/the-rest-api/",
	"title": "The REST API",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/weblogic-kubernetes-operator/userguide/managing-operators/using-the-operator/",
	"title": "Using the Operator",
	"tags": [],
	"description": "",
	"content": " Chapter 2 Using the Operator Lorem Ipsum.\n"
},
{
	"uri": "/weblogic-kubernetes-operator/userguide/managing-domains/domain-lifecycle/scaling/",
	"title": "Scaling",
	"tags": [],
	"description": "",
	"content": " WebLogic Server supports two types of clustering configurations, configured and dynamic. Configured clusters are created by manually configuring each individual Managed Server instance. In dynamic clusters, the Managed Server configurations are generated from a single, shared template. With dynamic clusters, when additional server capacity is needed, new server instances can be added to the cluster without having to manually configure them individually. Also, unlike configured clusters, scaling up of dynamic clusters is not restricted to the set of servers defined in the cluster but can be increased based on runtime demands. For more information on how to create, configure, and use dynamic clusters in WebLogic Server, see Dynamic Clusters.\nThe following blogs provide more in-depth information on support for scaling WebLogic clusters in Kubernetes:\n Automatic Scaling of WebLogic Clusters on Kubernetes WebLogic Dynamic Clusters on Kubernetes  The operator provides several ways to initiate scaling of WebLogic clusters, including:\n On-demand, updating the domain resource directly (using kubectl). Calling the operator\u0026rsquo;s REST scale API, for example, from curl. Using a WLDF policy rule and script action to call the operator\u0026rsquo;s REST scale API. Using a Prometheus alert action to call the operator\u0026rsquo;s REST scale API.  On-demand, updating the domain resource directly The easiest way to scale a WebLogic cluster in Kubernetes is to simply edit the replicas property within a domain resource. This can be done by using the kubectl command-line interface for running commands against Kubernetes clusters. More specifically, you can modify the domain resource directly by using the kubectl edit command. For example:\n$ kubectl edit domain domain1 -n [namespace]  Here we are editing a domain resource named domain1. The kubectl edit command will open the domain resource definition in an editor and allow you to modify the replicas value directly. Once committed, the operator will be notified of the change and will immediately attempt to scale the corresponding dynamic cluster by reconciling the number of running pods/Managed Server instances with the replicas value specification.\nspec: ... clusters: - clusterName: cluster-1 replicas: 1 ...  Alternatively, you can specify a default replicas value for all the clusters. If you do this, then you don\u0026rsquo;t need to list the cluster in the domain resource (unless you want to customize another property of the cluster).\nspec: ... replicas: 1 ...  Calling the operator\u0026rsquo;s REST scale API Scaling up or scaling down a WebLogic cluster provides increased reliability of customer applications as well as optimization of resource usage. In Kubernetes cloud environments, scaling WebLogic clusters involves scaling the corresponding pods in which WebLogic Managed Server instances are running. Because the operator manages the life cycle of a WebLogic domain, the operator exposes a REST API that allows an authorized actor to request scaling of a WebLogic cluster.\nThe following URL format is used for describing the resources for scaling (up and down) a WebLogic cluster:\nhttp(s)://${OPERATOR_ENDPOINT}/operator/\u0026lt;version\u0026gt;/domains/\u0026lt;domainUID\u0026gt;/clusters/\u0026lt;clusterName\u0026gt;/scale  For example:\nhttp(s)://${OPERATOR_ENDPOINT}/operator/v1/domains/domain1/clusters/cluster-1/scale  In this URL format:\n OPERATOR_ENDPOINT is the host and port of the operator REST endpoint (internal or external). \u0026lt;version\u0026gt; denotes the version of the REST resource. \u0026lt;domainUID\u0026gt; is the unique identifier of the WebLogic domain. \u0026lt;clusterName\u0026gt; is the name of the WebLogic cluster to be scaled.  The /scale REST endpoint accepts an HTTP POST request and the request body supports the JSON \u0026quot;application/json\u0026quot; media type. The request body will be a simple name-value item named managedServerCount; for example:\n{ \u0026quot;managedServerCount\u0026quot;: 3 }  The managedServerCount value designates the number of WebLogic Server instances to scale to. Note that the scale resource is implemented using the JAX-RS framework, and so a successful scaling request will return an HTTP response code of 204 (“No Content”) because the resource method’s return type is void and does not return a message body.\nWhen you POST to the /scale REST endpoint, you must send the following headers: * X-Requested-By request value. The value is an arbitrary name such as MyClient.\n* Authorization: Bearer request value. The value of the Bearer token is the WebLogic domain service account token.\nFor example, when using curl:\ncurl -v -k -H X-Requested-By:MyClient -H Content-Type:application/json -H Accept:application/json -H \u0026quot;Authorization:Bearer ...\u0026quot; -d '{ \u0026quot;managedServerCount\u0026quot;: 3 }' https://.../scaling  If you omit the header, you\u0026rsquo;ll get a 400 (bad request) response without any details explaining why the request was bad. If you omit the Bearer Authentication header, then you\u0026rsquo;ll get a 401 (Unauthorized) response.\nOperator REST endpoints The WebLogic Kubernetes Operator can expose both an internal and external REST HTTPS endpoint. The internal REST endpoint is only accessible from within the Kubernetes cluster. The external REST endpoint is accessible from outside the Kubernetes cluster. The internal REST endpoint is enabled by default and thus always available, whereas the external REST endpoint is disabled by default and only exposed if explicitly configured. Detailed instructions for configuring the external REST endpoint are available here.\nNOTE: Regardless of which endpoint is being invoked, the URL format for scaling is the same.\nWhat does the operator do in response to a scaling request? When the operator receives a scaling request, it will:\n Perform an authentication and authorization check to verify that the specified user is allowed to perform the specified operation on the specified resource. Validate that the specified domain, identified by domainUID, exists. Validate that the WebLogic cluster, identified by clusterName, exists. Verify that the specified WebLogic cluster has a sufficient number of configured servers to satisfy the scaling request. Initiate scaling by setting the replicas property within the corresponding domain resource, which can be done in either:  A cluster entry, if defined within its cluster list. At the domain level, if not defined in a cluster entry.   In response to a change to either replicas property, in the domain resource, the operator will increase or decrease the number of pods (Managed Servers) to match the desired replica count.\nUsing a WLDF policy rule and script action to call the operator\u0026rsquo;s REST scale API The WebLogic Diagnostics Framework (WLDF) is a suite of services and APIs that collect and surface metrics that provide visibility into server and application performance. To support automatic scaling of WebLogic clusters in Kubernetes, WLDF provides the Policies and Actions component, which lets you write policy expressions for automatically executing scaling operations on a cluster. These policies monitor one or more types of WebLogic Server metrics, such as memory, idle threads, and CPU load. When the configured threshold in a policy is met, the policy is triggered, and the corresponding scaling action is executed. The WebLogic Kubernetes Operator project provides a shell script, scalingAction.sh, for use as a Script Action, which illustrates how to issue a request to the operator’s REST endpoint.\nConfigure automatic scaling of WebLogic clusters in Kubernetes with WLDF The following steps are provided as a guideline on how to configure a WLDF Policy and Script Action component for issuing scaling requests to the operator\u0026rsquo;s REST endpoint: 1. Copy the scalingAction.sh script to a directory (such as $DOMAIN_HOME/bin/scripts) so that it\u0026rsquo;s accessible within the Administration Server pod. 2. Configure a WLDF policy and action as part of a diagnostic module targeted to the Administration Server. For information about configuring the WLDF Policies and Actions component, see Configuring Policies and Actions in Configuring and Using the Diagnostics Framework for Oracle WebLogic Server.\na. Configure a WLDF policy with a rule expression for monitoring WebLogic Server metrics, such as memory, idle threads, and CPU load for example.\nb. Configure a WLDF script action and associate the scalingAction.sh script.\nImportant notes about the configuration properties for the Script Action:\nThe scalingAction.sh script requires access to the SSL certificate of the operator’s endpoint and this is provided through the environment variable INTERNAL_OPERATOR_CERT.\nThe operator’s SSL certificate can be found in the internalOperatorCert entry of the operator’s ConfigMap weblogic-operator-cm:\nFor example:\n#\u0026gt; kubectl describe configmap weblogic-operator-cm -n weblogic-operator ... Data ==== internalOperatorCert: ---- LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUR3akNDQXFxZ0F3SUJBZ0lFRzhYT1N6QU... ...  The scalingAction.sh script accepts a number of customizable parameters:\n action - scaleUp or scaleDown (Required)\n domain_uid - WebLogic domain unique identifier (Required)\n cluster_name - WebLogic cluster name (Required)\n kubernetes_master - Kubernetes master URL, default=https://kubernetes\nNOTE: Set this to https://kubernetes.default.svc when invoking scalingAction.sh from the Administration Server pod.\n access_token - Service Account Bearer token for authentication and authorization for access to REST Resources\n wls_domain_namespace - Kubernetes namespace in which the WebLogic domain is defined, default=default\n operator_service_name - WebLogic Operator Service name of the REST endpoint, default=internal-weblogic-operator-service\n operator_service_account - Kubernetes Service Account name for the WebLogic Operator, default=weblogic-operator\n operator_namespace – Namespace in which the WebLogic Operator is deployed, default=weblogic-operator\n scaling_size – Incremental number of WebLogic Server instances by which to scale up or down, default=1\n  You can use any of the following tools to configure policies for diagnostic system modules: * WebLogic Server Administration Console * WLST * REST * JMX application\nA more in-depth description and example on using WLDF\u0026rsquo;s Policies and Actions component for initiating scaling requests through the operator\u0026rsquo;s REST endpoint can be found in the blogs: * Automatic Scaling of WebLogic Clusters on Kubernetes * WebLogic Dynamic Clusters on Kubernetes\nCreate cluster role bindings to allow a namespace user to query WLS Kubernetes cluster information The script scalingAction.sh, specified in the WLDF script action above, needs the appropriate RBAC permissions granted for the service account user (in the namespace in which the WebLogic domain is deployed) in order to query the Kubernetes API server for both configuration and runtime information of the domain resource. The following is an example YAML file for creating the appropriate Kubernetes cluster role bindings:\nIn the example cluster role binding definition below, the WebLogic domain is deployed to a namespace weblogic-domain. Replace the namespace value with the name of the namespace in which the WebLogic domain is deployed in your Kubernetes environment.\n\rkind: ClusterRole apiVersion: rbac.authorization.k8s.io/v1beta1 metadata: name: weblogic-domain-cluster-role rules: - apiGroups: [\u0026quot;weblogic.oracle\u0026quot;] resources: [\u0026quot;domains\u0026quot;] verbs: [\u0026quot;get\u0026quot;, \u0026quot;list\u0026quot;, \u0026quot;update\u0026quot;] --- # # creating role-bindings for cluster role # kind: ClusterRoleBinding apiVersion: rbac.authorization.k8s.io/v1beta1 metadata: name: domain-cluster-rolebinding subjects: - kind: ServiceAccount name: default namespace: weblogic-domain apiGroup: \u0026quot;\u0026quot; roleRef: kind: ClusterRole name: weblogic-domain-cluster-role apiGroup: \u0026quot;rbac.authorization.k8s.io\u0026quot; --- # # creating role-bindings # kind: RoleBinding apiVersion: rbac.authorization.k8s.io/v1beta1 metadata: name: weblogic-domain-operator-rolebinding namespace: weblogic-operator subjects: - kind: ServiceAccount name: default namespace: weblogic-domain apiGroup: \u0026quot;\u0026quot; roleRef: kind: ClusterRole name: cluster-admin apiGroup: \u0026quot;rbac.authorization.k8s.io\u0026quot; ---  Using a Prometheus alert action to call the operator\u0026rsquo;s REST scale API In addition to using the WebLogic Diagnostic Framework for automatic scaling of a dynamic cluster, you can use a third-party monitoring application like Prometheus. Please read the following blog for details about Using Prometheus to Automatically Scale WebLogic Clusters on Kubernetes.\nHelpful Tips Debugging scalingAction.sh The scalingAction.sh script was designed to be executed within the Administration Server pod because the associated diagnostic module is targed to the Administration Server.\nThe easiest way to verify and debug the scalingAction.sh script is to open a shell on the running Administration Server pod and execute the script on the command line.\nThe following example illustrates how to open a bash shell on a running Administration Server pod named domain1-admin-server and execute the scriptAction.sh script. It assumes that: * The domain home is in /u01/oracle/user-projects/domains/domain1 (that is, the domain home is inside a Docker image). * The Dockerfile copied scalingAction.sh to /u01/oracle/user-projects/domains/domain1/bin/scripts/scalingAction.sh.\n\u0026gt; kubectl exec -it domain1-admin-server /bin/bash # bash\u0026gt; cd /u01/oracle/user-projects/domains/domain1/bin/scripts # bash\u0026gt; ./scalingAction.sh  A log, scalingAction.log, will be generated in the same directory in which the script was executed and can be examined for errors.\nExample on accessing the external REST endpoint The easiest way to test scaling using the external REST endpoint is to use a command-line tool like curl. Using curl to issue an HTTPS scale request requires these mandatory header properties: * Bearer Authorization token * SSL certificate for the operator\u0026rsquo;s external REST endpoint * X-Requested-By header value\nThe following shell script is an example of how to issue a scaling request, with the necessary HTTP request header values, using curl. This example assumes the operator and domain resource are configured with the following properties in Kubernetes: * Operator properties: * externalRestEnabled: true * externalRestHttpsPort: 31001 * operator\u0026rsquo;s namespace: weblogic-operator * operator\u0026rsquo;s hostname is the same as the host shell script is executed on. * Domain resource properties:\n* WebLogic cluster name: DockerCluster * Domain UID: domain1\n#!/bin/sh # Setup properties ophost=`uname -n` opport=31001 #externalRestHttpsPort cluster=cluster-1 size=3 #New cluster size ns=weblogic-operator # Operator NameSpace sa=weblogic-operator # Operator ServiceAccount domainuid=domain1 # Retrieve service account name for given namespace sec=`kubectl get serviceaccount ${sa} -n ${ns} -o jsonpath='{.secrets[0].name}'` #echo \u0026quot;Secret [${sec}]\u0026quot; # Retrieve base64 encoded secret for the given service account enc_token=`kubectl get secret ${sec} -n ${ns} -o jsonpath='{.data.token}'` #echo \u0026quot;enc_token [${enc_token}]\u0026quot; # Decode the base64 encoded token token=`echo ${enc_token} | base64 --decode` #echo \u0026quot;token [${token}]\u0026quot; # clean up any temporary files rm -rf operator.rest.response.body operator.rest.stderr operator.cert.pem # Retrieve SSL certificate from the Operator's external REST endpoint `openssl s_client -showcerts -connect ${ophost}:${opport} \u0026lt;/dev/null 2\u0026gt;/dev/null | openssl x509 -outform PEM \u0026gt; operator.cert.pem` echo \u0026quot;Rest EndPoint url https://${ophost}:${opport}/operator/v1/domains/${domainuid}/clusters/${cluster}/scale\u0026quot; # Issue 'curl' request to external REST endpoint curl --noproxy '*' -v --cacert operator.cert.pem \\ -H \u0026quot;Authorization: Bearer ${token}\u0026quot; \\ -H Accept:application/json \\ -H \u0026quot;Content-Type:application/json\u0026quot; \\ -H \u0026quot;X-Requested-By:WLDF\u0026quot; \\ -d \u0026quot;{\\\u0026quot;managedServerCount\\\u0026quot;: $size}\u0026quot; \\ -X POST https://${ophost}:${opport}/operator/v1/domains/${domainuid}/clusters/${cluster}/scale \\ -o operator.rest.response.body \\ --stderr operator.rest.stderr  "
},
{
	"uri": "/weblogic-kubernetes-operator/userguide/managing-domains/integrations/exporting-metrics/prometheus/",
	"title": "Prometheus",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/weblogic-kubernetes-operator/userguide/managing-domains/integrations/exporting-logs/",
	"title": "Exporting Logs",
	"tags": [],
	"description": "",
	"content": " Chapter 2 Exporting Logs Lorem Ipsum.\n"
},
{
	"uri": "/weblogic-kubernetes-operator/userguide/managing-domains/domain-in-image/patching/",
	"title": "Patching",
	"tags": [],
	"description": "",
	"content": " Chapter 2 Patching Lorem Ipsum.\n"
},
{
	"uri": "/weblogic-kubernetes-operator/userguide/managing-domains/persistent-storage/",
	"title": "Persistent Storage",
	"tags": [],
	"description": "",
	"content": " Chapter 2 Persistent Storage Lorem Ipsum.\n"
},
{
	"uri": "/weblogic-kubernetes-operator/userguide/introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": " Introduction This document provides detailed user information for the Oracle WebLogic Server Kubernetes Operator. It provides instructions on how to install the operator in your Kubernetes cluster and how to use it to manage WebLogic domains.\nIf you are looking for information about how the operator is designed, implemented, built, and such, then you should refer to the Developer guide.\nImportant terms This documentation uses several important terms which are intended to have a specific meaning.\n   Term Definition     Cluster Because this term is ambiguous, it will be prefixed to indicate which type of cluster is meant. A WebLogic cluster is a group of Managed Servers that together host some application or component and which are able to share load and state between them. A Kubernetes cluster is a group of machines (“nodes”) that all host Kubernetes resources, like pods and services, and which appear to the external user as a single entity. If the term “cluster” is not prefixed, it should be assumed to mean a Kubernetes cluster.   Domain A WebLogic domain is a group of related applications and resources along with the configuration information necessary to run them.   Ingress A Kubernetes Ingress provides access to applications and services in a Kubernetes environment to external clients. An Ingress may also provide additional features like load balancing.   Namespace A Kubernetes namespace is a named entity that can be used to group together related objects, for example, pods and services.   Operator A Kubernetes operator is software that performs management of complex applications.   Pod A Kubernetes pod contains one or more containers and is the object that provides the execution environment for an instance of an application component, such as a web server or database.   Job A Kubernetes job is a type of controller that creates one or more pods that run to completion to complete a specific task.   Secret A Kubernetes secret is a named object that can store secret information like user names, passwords, X.509 certificates, or any other arbitrary data.   Service A Kubernetes service exposes application endpoints inside a pod to other pods, or outside the Kubernetes cluster. A service may also provide additional features like load balancing.    Additional reading Before using the operator, you might want to read the design philosophy to develop an understanding of the operator\u0026rsquo;s design, and the architectural overview to understand its architecture, including how WebLogic domains are deployed in Kubernetes using the operator. Also, worth reading are the details of the Kubernetes RBAC definitions required by the operator.\n"
},
{
	"uri": "/weblogic-kubernetes-operator/reference/swagger/",
	"title": "Swagger",
	"tags": [],
	"description": "",
	"content": "You can view the Swagger REST API documentation here.\n"
},
{
	"uri": "/weblogic-kubernetes-operator/quickstart/prerequisites/",
	"title": "Prerequisites",
	"tags": [],
	"description": "",
	"content": "For this exercise, you’ll need a Kubernetes cluster. If you need help setting one up, check out our cheat sheet. This guide assumes a single node cluster.\nThe operator uses Helm to create and deploy the necessary resources and then run the operator in a Kubernetes cluster. For Helm installation and usage information, see Install Helm and Tiller.\nYou should clone this repository to your local machine so that you have access to the various sample files mentioned throughout this guide:\n$ git clone https://github.com/oracle/weblogic-kubernetes-operator  "
},
{
	"uri": "/weblogic-kubernetes-operator/userguide/",
	"title": "User Guide",
	"tags": [],
	"description": "",
	"content": " User Guide The User Guide provides detailed information about all aspects of using the operator.\n"
},
{
	"uri": "/weblogic-kubernetes-operator/userguide/managing-domains/domain-lifecycle/restarting/",
	"title": "Restarting",
	"tags": [],
	"description": "",
	"content": " Restarting Oracle WebLogic Server in Kubernetes This document describes when to restart servers in the Oracle WebLogic Server in Kubernetes environment.\nOverview There are many situations where changes to the Oracle WebLogic Server in Kubernetes environment require that all the servers in a domain or cluster be restarted, for example, when applying a WebLogic Server patch or when upgrading an application.\nOne of the operator\u0026rsquo;s most important jobs is to start and stop WebLogic Servers by creating and deleting their corresponding Kubernetes pods. Sometimes, you need to make changes that make the pods obsolete, therefore the pods need to be deleted and recreated. Depending on the change, sometimes the pods can be gradually recreated, without taking the entire domain out of service (for example, rolling restarts) and sometimes all the pods need to be deleted then recreated, taking the entire domain out of service for a while (for example, full restarts).\nThe following types of server restarts are supported in Oracle WebLogic Server in Kubernetes:\n Rolling restarts - a coordinated and controlled shut down of all of the servers in a domain or cluster while ensuring that service to the end user is not interrupted.\n Operator initiated - where the WebLogic Kubernetes Operator can detect some types of changes and will automatically initiate rolling restarts of server pods in a WebLogic domain.\n Manually initiated - required when certain changes in the Oracle WebLogic Server in Kubernetes environment cannot be detected by the operator, so a rolling restart must be manually initiated.\n  Full domain restarts - the Administration Server and all the Managed Servers in a domain are shutdown, impacting service availability to the end user, and then restarted. Unlike a rolling restart, the operator cannot detect and initiate a full domain restart; it must always be manually initiated.\n  For detailed information on how to restart servers in a Oracle WebLogic Server in Kubernetes environment, see Starting, stopping, and restarting servers.\nCommon restart scenarios This document describes what actions you need to take to properly restart your servers for a number of common scenarios:\n Modifying the WebLogic configuration Changing the custom domain configuration overrides (also called situational configuration) Changing the WebLogic Server credentials (the user name and password) Changing properties on the domain resource that affect server pods (such as image, volumes, and env) Applying WebLogic Server patches Updating deployed applications for domain home in image  Use cases Modifying the WebLogic configuration Changes to the Oracle WebLogic Server configuration may require either a rolling or full domain restart depending on the domain home location and the type of configuration change.\n Domain home in image: For domain home in image, any changes (dynamic or non-dynamic) to the WebLogic configuration requires a full domain restart.\n If you create a new image with a new name, then you must avoid a rolling restart, which can cause unexpected behavior for the running domain due to configuration inconsistencies as seen by the various servers, by following the steps in Avoiding a rolling restart when changing image property on a domain resource. If you create a new image with the same name, then you must manually initiate a full domain restart. See Full domain restarts in Starting, stopping, and restarting servers.  Domain home on PV: For domain home on PV, the type of restart needed to apply the changes, depends on the nature of the WebLogic configuration change:\n Changes to parts of the WebLogic configuration that the operator introspects, require a full restart, even if the changes are dynamic. The following are the types of changes to the WebLogic Server configuration that the operator introspects:  Adding or removing a cluster, server, dynamic server, or network access point Changing a cluster, server, dynamic server, or network access point name Enabling or disabling the listen port, SSL port, or admin port Changing any port numbers Changing a network access point\u0026rsquo;s public address  Other dynamic WebLogic configuration changes do not require a restart. For example, a change to a server\u0026rsquo;s connection timeout property is dynamic and does not require a restart. Other non-dynamic WebLogic configuration changes require either a manually initiated rolling restart or a full domain restart, depending on the nature of the change. For example, a rolling restart is applicable when changing a WebLogic Server\u0026rsquo;s stuck thread timer interval property. See Restart all the servers in the domain in Starting, stopping, and restarting servers.   Changing the custom domain configuration overrides Any change to domain configuration overrides requires a full domain restart. This includes: * Changing the domain resource\u0026rsquo;s configOverides to point to a different configuration map * Changing the domain resource\u0026rsquo;s configOverridesSecrets to point to a different list of secrets * Changing the contents of the configuration map referenced by configOverrides * Changing the contents to any of the secrets referenced by configOverridesSecrets\nChanging the WebLogic Server credentials A change to the WebLogic Server credentials (the user name and password), contained in the Kubernetes secret for the domain, requires a full domain restart. The Kubernetes secret can be updated directly or a new secret can be created and then referenced by the webLogicCredentialsSecret property in the domain resource.\nChanging properties on the domain resource that affect server pods The operator will initiate a rolling restart of the domain when you modify any of the domain resource properties that affect the server pods configuration, such as image, volumes, and env. For a complete list, see Properties that cause servers to be restarted in Starting, stopping, and restarting servers.\nYou can modify these properties using the kubectl command-line tool\u0026rsquo;s edit and patch commands or through the Kubernetes REST API.\nFor example, to edit the domain resource directly using the kubectl command-line tool:\nkubectl edit domain \u0026lt;domain name\u0026gt; -n \u0026lt;domain namespace\u0026gt;  The edit command opens a text editor which lets you edit the domain resource in place.\nNote: Typically, it\u0026rsquo;s better to edit the domain resource directly; otherwise, if you scaled the domain, and you just edit the original domain.yaml file and reapply it, you could go back to your old replicas count.\nApplying WebLogic Server patches Oracle provides different types of patches for WebLogic Server, such as Patch Set Updates, Security Patch Updates, and One-Off patches. Information on whether a patch is rolling compatible or requires a manual full domain restart usually can be found in the patch\u0026rsquo;s documentation, such as the README file.\nWebLogic Server patches can be applied to either a domain home in image or a domain home on PV:\nWith rolling compatible patches: * If you update the image property with a new image name, then the operator will initiate a rolling restart. * If you keep the same image name, then you must manually initiate a rolling restart. See Restart all the servers in the domain in Starting, stopping, and restarting servers.\nWith patches that are not rolling compatible: * If you keep the same image name, then you must manually initiate a full domain restart. See Full domain restarts in Starting, stopping, and restarting servers. * If you update the image property with a new image name, then you must avoid the rolling restart by following the steps in Avoiding a rolling restart when changing image property on a domain resource.\nUpdating deployed applications for domain home in image Frequent updates of deployed applications using a continuous integration/continuous delivery (CI/CD) process is a very common use case. The process for applying an updated application is different for domain home in image than it is for domain home on PV. A rolling compatible application update is where some servers are running the old version and some are running the new version of the application during the rolling restart process. On the other hand, an application update that is not rolling compatible requires that all the servers in the domain be shutdown and restarted.\nIf the application update is rolling compatible: * If you update the image property with a new image name, then the operator will initiate a rolling restart. * If you keep the same image name, then you must manually initiate a rolling restart. See Restart all the servers in the domain in Starting, stopping, and restarting servers.\nIf the application update is not rolling compatible: * If you keep the same image name, then you must manually initiate a full domain restart. See Full domain restarts in Starting, stopping, and restarting servers. * If you update the image property with a new image name, then you must avoid the rolling restart by following the steps in Avoiding a rolling restart when changing image property on a domain resource.\nRolling out an updated domain home in image Follow these steps to create new rolling compatible image if you only need to patch your WebLogic Server domain or update application deployment files:\n Select a different name for the new image.\n Using the same domain home-in-image Docker image as a base, create a new Docker image by copying (COPY command in a Dockerfile) the updated application deployment files or WebLogic Server patches into the Docker image during the Docker image build.\nNOTE: The key here is to make sure that you do not re-run WLST or WDT to create a new domain home even though it will have the same configuration. Creating a new domain will change the domain secret and you won\u0026rsquo;t be able to do a rolling restart.\n Deploy the new Docker image to your Docker repository with the new name.\n Update the image property of the domain resource specifying the new image name.\n  For example:\n ``` domain: spec: image: oracle/weblogic-updated:2.0 ```   The operator will now initiate a rolling restart, which will apply the updated image, for all the server pods in the domain.  Avoiding a rolling restart when changing image property on a domain resource If you\u0026rsquo;ve created a new image that is not rolling compatible, and you\u0026rsquo;ve changed the image name, then:\n Bring the domain down (stopping all the server pods) by setting the serverStartPolicy to NEVER. See Shut down all the servers in Starting, stopping, and restarting servers.\n Update the image property with a new image name.\n Start up the domain (starting all the server pods) by setting the serverStartPolicy to IF_NEEDED.\n  Other considerations for restarting a domain  Consider the order of changes:\nIf you need to make multiple changes to your domain at the same time, you\u0026rsquo;ll want to be careful about the order in which you do your changes, so that servers aren\u0026rsquo;t restarted prematurely or restarted needlessly. For example, if you want to change the readiness probe\u0026rsquo;s tuning parameters and the Java options (both of which are rolling compatible), then you should update the domain resource once, changing both values, so that the operator rolling restarts the servers once. Or, if you want to change the readiness probe\u0026rsquo;s tuning parameters (which is rolling compatible) and change the domain customizations (which require a full restart), then you should do a full shutdown first, then make the changes, and then restart the servers.\nAlternatively, if you know that your set of changes are not rolling compatible, then you must avoiding a rolling restart by:\n Bringing the domain down (stopping all the server pods) by setting the serverStartPolicy to NEVER. See Shut down all the servers in Starting, stopping, and restarting servers.\n Make all your changes to the Oracle WebLogic Server in Kubernetes environment.\n Starting up the domain (starting all the server pods) by setting the serverStartPolicy to IF_NEEDED.\n  Changes that require domain knowledge.\nSometimes you need to make changes that require server restarts, yet the changes are not to the WebLogic configuration, the image, or the Kubernetes resources that register your domain with the operator. For example, your servers are caching information from an external database and you\u0026rsquo;ve modified the contents of the database.\nIn these cases, you must manually initiate a restart.\n  "
},
{
	"uri": "/weblogic-kubernetes-operator/userguide/introduction/architecture/",
	"title": "Architectural overview",
	"tags": [],
	"description": "",
	"content": " The operator consists of the following parts:\n The operator runtime, a process that runs in a Docker container deployed into a Kubernetes pod and which performs the actual management tasks. The model for a Kubernetes custom resource definition (CRD) that when installed in a Kubernetes cluster allows the Kubernetes API server to manage instances of this new type representing the operational details and status of WebLogic domains. A Helm chart for installing the operator runtime and related resources. A variety of sample shell scripts for preparing or packaging WebLogic domains for running in Kubernetes. A variety of sample Helm charts or shell scripts for conditionally exposing WebLogic endpoints outside the Kubernetes cluster.  The operator is packaged in a Docker image which you can access using the following docker pull commands:\n$ docker login $ docker pull oracle/weblogic-kubernetes-operator:2.0-rc2  For more details on acquiring the operator image and prerequisites for installing the operator, consult the Quick Start guide.\nThe operator registers a Kubernetes custom resource definition called domain.weblogic.oracle (shortname domain, plural domains). More details about the domain resource type defined by this CRD, including its schema, are available here.\nThe diagram below shows the general layout of high-level components, including optional components, in a Kubernetes cluster that is hosting WebLogic domains and the operator:\nThe Kubernetes cluster has several namespaces. Components may be deployed into namespaces as follows:\n The operator is deployed into its own namespace. If the Elastic Stack integration option is configured, then a Logstash pod will also be deployed in the operator’s namespace. WebLogic domains will be deployed into various namespaces. There can be more than one domain in a namespace, if desired. There is no limit on the number of domains or namespaces that an operator can manage. Note that there can be more than one operator in a Kubernetes cluster, but each operator is configured with a list of the specific namespaces that it is responsible for. The operator will not take any action on any domain that is not in one of the namespaces the operator is configured to manage. Customers are responsible for load balancer configuration, which will typically be in the same namespace with domains or in a system, shared namespace such as the kube-system namespace. Customers are responsible for Elasticsearch and Kibana deployment, which are typically deployed in the default namespace.  Domain architecture The diagram below shows how the various parts of a WebLogic domain are manifest in Kubernetes by the operator.\nThis diagram shows the following details:\n An optional, persistent volume is created by the customer using one of the available providers. If the persistent volume is shared across the domain or members of a cluster, then the chosen provider must support “Read Write Many” access mode. The shared state on the persistent volume may include the “domain” directory, the “applications” directory, a directory for storing logs, and a directory for any file-based persistence stores. A pod is created for the WebLogic Administration Server. This pod is labeled with weblogic.domainUID, weblogic.serverName, and weblogic.domainName. One container runs in this pod. WebLogic Node Manager and Administration Server processes are run inside this container. The Node Manager process is used as an internal implementation detail for the liveness probe, for patching, and to provide monitoring and control capabilities to the Administration Console. It is not intended to be used for other purposes, and it may be removed in some future release. A ClusterIP type service is created for the Administration Server pod. This service provides a stable, well-known network (DNS) name for the Administration Server. This name is derived from the domainUID and the Administration Server name, and it is known before starting up any pod. The Administration Server ListenAddress is set to this well-known name. ClusterIP type services are only visible inside the Kubernetes cluster. They are used to provide the well-known names that all of the servers in a domain use to communicate with each other. This service is labeled with weblogic.domainUID and weblogic.domainName. A NodePort type service is optionally created for the Administration Server pod. This service provides HTTP access to the Administration Server to clients that are outside the Kubernetes cluster. This service is intended to be used to access the WebLogic Server Administration Console or for the T3 protocol for WLST connections. This service is labeled with weblogic.domainUID and weblogic.domainName. A pod is created for each WebLogic Managed Server. These pods are labeled with weblogic.domainUID, weblogic.serverName, and weblogic.domainName. One container runs in each pod. WebLogic Node Manager and Managed Server processes are run inside each of these containers. The Node Manager process is used as an internal implementation detail for the liveness probe. It is not intended to be used for other purposes, and it may be removed in some future release. A ClusterIP type service is created for each Managed Server pod that contains a Managed Server that is not part of a WebLogic cluster. These services are intended to be used to access applications running on the Managed Servers. These services are labeled with weblogic.domainUID and weblogic.domainName. Customers must expose these services using a load balancer or NodePort type service to expose these endpoints outside the Kubernetes cluster. An Ingress may optionally be created by the customer for each WebLogic cluster. An Ingress provides load balanced HTTP access to all Managed Servers in that WebLogic cluster. The load balancer updates its routing table for an Ingress every time a Managed Server in the WebLogic cluster becomes “ready” or ceases to be able to service requests, such that the Ingress always points to just those Managed Servers that are able to handle user requests.  The diagram below shows the components inside the containers running WebLogic Server instances:\nThe domain resource specifies a Docker image, defaulting to store/oracle/weblogic:12.2.1.3. All containers running WebLogic Server use this same Docker image. Depending on the use case, this image could contain the WebLogic Server product binaries or also include the domain directory. Note: During a rolling event caused by a change to the domain resource\u0026rsquo;s image field, containers will be using a mix of the updated value of the image field and its previous value.\nWithin the container, the following aspects are configured by the operator:\n The ENTRYPOINT is configured by a script that starts up a Node Manager process, and then uses WLST to request that Node Manager start the server. Node Manager is used to start servers so that the socket connection to the server will be available to obtain server status even when the server is unresponsive. This is used by the liveness probe. The liveness probe is configured to check that the server is alive by querying the Node Manager process. The liveness probe is by default configured to check liveness every 15 seconds, and to timeout after 5 seconds. If a pod fails the liveness probe, Kubernetes will restart that container. The readiness probe is configured to use the WebLogic Server ReadyApp framework. The readiness probe is used to determine if the server is ready to accept user requests. The readiness is used to determine when a server should be included in a load balancer\u0026rsquo;s endpoints, when a restarted server is fully started in the case of a rolling restart, and for various other purposes. A shutdown hook is configured that will execute a script that performs a graceful shutdown of the server. This ensures that servers have an opportunity to shut down cleanly before they are killed.  Domain state stored outside Docker images The operator expects (and requires) that all state be stored outside of the Docker images that are used to run the domain. This means either in a persistent file system, or in a database. The WebLogic configuration, that is, the domain directory and the applications directory may come from the Docker image or a persistent volume. However, other state, such as file-based persistent stores, and such, must be stored on a persistent volume or in a database. All of the containers that are participating in the WebLogic domain use the same image, and take on their personality; that is, which server they execute, at startup time. Each pod mounts storage, according to the domain resource, and has access to the state information that it needs to fulfill its role in the domain.\nIt is worth providing some background information on why this approach was adopted, in addition to the fact that this separation is consistent with other existing operators (for other products) and the Kubernetes “cattle, not pets” philosophy when it comes to containers.\nThe external state approach allows the operator to treat the Docker images as essentially immutable, read-only, binary images. This means that the image needs to be pulled only once, and that many domains can share the same image. This helps to minimize the amount of bandwidth and storage needed for WebLogic Server Docker images.\nThis approach also eliminates the need to manage any state created in a running container, because all of the state that needs to be preserved is written into either the persistent volume or a database back end. The containers and pods are completely throwaway and can be replaced with new containers and pods, as necessary. This makes handling failures and rolling restarts much simpler because there is no need to preserve any state inside a running container.\nWhen users wish to apply a binary patch to WebLogic Server, it is necessary to create only a single new, patched Docker image. If desired, any domains that are running may be updated to this new patched image with a rolling restart, because there is no state in the containers.\nIt is envisaged that in some future release of the operator, it will be desirable to be able to “move” or “copy” domains in order to support scenarios like Kubernetes federation, high availability, and disaster recovery. Separating the state from the running containers is seen as a way to greatly simplify this feature, and to minimize the amount of data that would need to be moved over the network, because the configuration is generally much smaller than the size of WebLogic Server Docker images.\nThe team developing the operator felt that these considerations provided adequate justification for adopting the external state approach.\nNetwork name predictability The operator uses services to provide stable, well-known DNS names for each server. These names are known in advance of starting up a pod to run a server, and are used in the ListenAddress fields in the WebLogic Server configuration to ensure that servers will always be able to find each other. This also eliminates the need for pod names or the actual WebLogic Server instance names to be the same as the DNS addresses.\n"
},
{
	"uri": "/weblogic-kubernetes-operator/userguide/managing-domains/accessing-the-domain/rest/",
	"title": "WebLogic REST APIs",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/weblogic-kubernetes-operator/userguide/managing-domains/accessing-the-domain/wlst/",
	"title": "Using WLST",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/weblogic-kubernetes-operator/samples/simple/domains/",
	"title": "Domains",
	"tags": [],
	"description": "",
	"content": " Chapter 3 Domains Lorem Ipsum.\n"
},
{
	"uri": "/weblogic-kubernetes-operator/developerguide/building/",
	"title": "Building",
	"tags": [],
	"description": "",
	"content": " The operator is built using Apache Maven. The build machine will also need to have Docker installed.\nTo build the operator, issue the following command in the project directory:\n$ mvn clean install  This will compile the source files, build JAR files containing the compiled classes and libraries needed to run the operator, and will also execute all of the unit tests.\nContributions must conform to coding and formatting standards. To automatically update local code to conform to formatting standards, issue the following command:\n$ mvn fmt:format  Building Javadoc To build the Javadoc for the operator, issue the following command:\n$ mvn javadoc:javadoc  The Javadoc is also available in the GitHub repository here.\nBuilding the operator Docker image Log in to the Docker Store so that you will be able to pull the base image and create the Docker image as follows. These commands should be executed in the project root directory:\n$ docker login $ docker build --build-arg VERSION=\u0026lt;version\u0026gt; -t weblogic-kubernetes-operator:some-tag --no-cache=true .  Replace \u0026lt;version\u0026gt; with the version of the project found in the pom.xml file in the project root directory.\nNote: If you have not used the base image (store/oracle/serverjre:8) before, you will need to visit the Docker Store web interface and accept the license agreement before the Docker Store will give you permission to pull that image.\nWe recommend that you use a tag other than latest, to make it easy to distinguish your image. In the example above, the tag could be the GitHub ID of the developer.\nRunning the operator from an IDE The operator can be run from an IDE, which is useful for debugging. In order to do so, the machine running the IDE must be configured with a Kubernetes configuration file in ~/.kube/config or in a location pointed to by the KUBECONFIG environment variable.\nConfigure the IDE to run the class oracle.kubernetes.operator.Main.\nYou may need to create a directory called /operator on your machine. Please be aware that the operator code is targeted to Linux, and although it will run fine on macOS, it will probably not run on other operating systems. If you develop on another operating system, you should deploy the operator to a Kubernetes cluster and use remote debugging instead.\nRunning the operator in a Kubernetes cluster If you\u0026rsquo;re not running Kubernetes on your development machine, you\u0026rsquo;ll need to make the Docker image available to a registry visible to your Kubernetes cluster. Either docker push the image to a private registry or upload your image to a machine running Docker and Kubernetes as follows:\n# on your build machine $ docker save weblogic-kubernetes-operator:some-tag \u0026gt; operator.tar $ scp operator.tar YOUR_USER@YOUR_SERVER:/some/path/operator.tar # on the Kubernetes server $ docker load \u0026lt; /some/path/operator.tar  Use the Helm charts to install the operator.\nIf the operator\u0026rsquo;s behavior or pod log is insufficient to diagnose and resolve failures, then you can connect a Java debugger to the operator using the debugging options.\n"
},
{
	"uri": "/weblogic-kubernetes-operator/userguide/managing-operators/using-the-operator/lifecycle/",
	"title": "Lifecycle",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/weblogic-kubernetes-operator/userguide/managing-domains/domain-in-image/domain-images/",
	"title": "Domain Images",
	"tags": [],
	"description": "",
	"content": " Chapter 3 Domain Images Lorem Ipsum.\n"
},
{
	"uri": "/weblogic-kubernetes-operator/userguide/managing-domains/domain-in-image/",
	"title": "Domain in Image",
	"tags": [],
	"description": "",
	"content": " Chapter 3 Domain in Image Lorem Ipsum.\n"
},
{
	"uri": "/weblogic-kubernetes-operator/userguide/managing-operators/",
	"title": "Managing Operators",
	"tags": [],
	"description": "",
	"content": " Chapter 2 Managing Operators Lorem Ipsum.\n"
},
{
	"uri": "/weblogic-kubernetes-operator/quickstart/get-images/",
	"title": "Get images",
	"tags": [],
	"description": "",
	"content": " Get these images and put them into your local registry. a. If you don\u0026rsquo;t already have one, obtain a Docker store account, log in to the Docker store and accept the license agreement for the WebLogic Server image.\nb. Log in to the Docker store from your Docker client:\n$ docker login  c. Pull the operator image:\n$ docker pull oracle/weblogic-kubernetes-operator:2.0-rc2  d. Pull the Traefik load balancer image:\n$ docker pull traefik:1.7.6  e. Pull the WebLogic 12.2.1.3 install image:\n$ docker pull store/oracle/weblogic:12.2.1.3  The existing WebLogic Docker image, store/oracle/weblogic:12.2.1.3, was updated on January 17, 2019, and has all the necessary patches applied; a docker pull is required if you pulled the image prior to that date.\n\rf. Copy the image to all the nodes in your cluster, or put it in a Docker registry that your cluster can access.\n"
},
{
	"uri": "/weblogic-kubernetes-operator/samples/",
	"title": "Samples",
	"tags": [],
	"description": "",
	"content": " Chapter 3 Samples Lorem Ipsum.\n"
},
{
	"uri": "/weblogic-kubernetes-operator/userguide/introduction/design/",
	"title": "Design philosophy",
	"tags": [],
	"description": "",
	"content": "The Oracle WebLogic Server Kubernetes Operator (the “operator”) is designed to fulfill a similar role to that which a human operator would fill in a traditional data center deployment. It contains a set of useful built-in knowledge about how to perform various lifecycle operations on a domain correctly.\nHuman operators are normally responsible for starting and stopping environments, initiating backups, performing scaling operations, performing manual tasks associated with disaster recovery and high availability needs and coordinating actions with other operators in other data centers. It is envisaged that the operator will have similar responsibilities in a Kubernetes environment.\nIt is important to note the distinction between an operator and an administrator. A WebLogic Server administrator typically has different responsibilities centered around managing the detailed configuration of the WebLogic domains. The operator has only limited interest in the domain configuration, with its main concern being the high-level topology of the domain; for example, how many clusters and servers, and information about network access points, such as channels.\nHuman operators may manage more than one domain, and the operator is also designed to be able to manage more than one domain. Like its human counterpart, the operator will only take actions against domains that it is told to manage, and will ignore any other domains that may be present in the same environment.\nLike a human operator, the operator is designed to be event-based. It waits for a significant event to occur, or for a scheduled time to perform some action, and then takes the appropriate action. Examples of significant events include being made aware of a new domain that needs to be managed, receiving a request to scale up a WebLogic cluster, or receiving a request to perform a backup of a domain.\nThe operator is designed with security in mind from the outset. Some examples of the specific security practices we follow are:\n During the deployment of the operator, Kubernetes roles are defined and assigned to the operator. These roles are designed to give the operator the minimum amount of privileges that it requires to perform its tasks. The code base is regularly scanned with security auditing tools and any issues that are identified are promptly resolved. All HTTP communications – between the operator and an external client, between the operator and WebLogic Administration Servers, and so on – are configured to require SSL and TLS 1.2. Unused code is pruned from the code base regularly. Dependencies are kept as up-to-date as possible and are regularly reviewed for security vulnerabilities.  The operator is designed to avoid imposing any arbitrary restriction on how WebLogic Server may be configured or used in Kubernetes. Where there are restrictions, these are based on the availability of some specific feature in Kubernetes; for example, multicast support.\nThe operator learns of WebLogic domains through instances of a domain Kubernetes resource. When the operator is installed, it creates a Kubernetes Custom Resource Definition. This custom resource definition defines the domain resource type. After this type is defined, you can manage domain resources using kubectl just like any other resource type. For instance, kubectl get domain or kubectl edit domain domain1.\nSchema for domain resources is here.\nThe schema for the domain resource is designed to be as sparse as possible. It includes the connection details for the Administration Server, but all of the other content is operational details about which servers should be started, environment variables, and details about what should be exposed outside the Kubernetes cluster. This way, the WebLogic domain\u0026rsquo;s configuration remains the normative configuration.\n"
},
{
	"uri": "/weblogic-kubernetes-operator/userguide/managing-domains/accessing-the-domain/applications/",
	"title": "Applications",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/weblogic-kubernetes-operator/samples/simple/rest/",
	"title": "REST APIs",
	"tags": [],
	"description": "",
	"content": " Chapter 4 REST APIs Lorem Ipsum.\n"
},
{
	"uri": "/weblogic-kubernetes-operator/developerguide/integration-tests/",
	"title": "Integration Tests",
	"tags": [],
	"description": "",
	"content": "The project includes integration tests that can be run against a Kubernetes cluster. If you want to use these tests, you will need to provide your own Kubernetes cluster. The Kubernetes cluster must meet the version number requirements and have Helm installed. Ensure that the operator Docker image is in a Docker registry visible to the Kubernetes cluster.\nYou will need to obtain the kube.config file for an administrative user and make it available on the machine running the build. To run the tests, update the KUBECONFIG environment variable to point to your config file and then execute:\n$ mvn clean verify -P java-integration-tests  When you run the integrations tests, they do a cleanup of any operator or domains on that cluster.\n\r"
},
{
	"uri": "/weblogic-kubernetes-operator/developerguide/branching/",
	"title": "Branching",
	"tags": [],
	"description": "",
	"content": "The master branch is protected and contains source for the most recently published release, including release candidates.\nThe develop branch is protected and contains source for the latest completed features and bug fixes. While this branch contains active work, we expect to keep it always \u0026ldquo;ready to release.\u0026rdquo; Therefore, longer running feature work will be performed on specific branches, such as feature/dynamic-clusters.\nBecause we want to balance separating destabilizing work into feature branches against the possibility of later difficult merges, we encourage developers working on features to pull out any necessary refactoring or improvements that are general purpose into their own shorter-lived branches and create pull requests to develop when these smaller work items are completed.\nAll commits to develop must pass the integration test suite. Please run these tests locally before submitting a pull request. Additionally, each push to a branch in our GitHub repository triggers a run of a subset of the integration tests with the results visible here.\nPlease submit pull requests to the develop branch unless you are collaborating on a feature and have another target branch. Please see details on the Oracle Contributor Agreement (OCA) and guidelines for pull requests on the README.\nWe will create git tags for each release candidate and generally available (GA) release of the operator.\n"
},
{
	"uri": "/weblogic-kubernetes-operator/userguide/managing-operators/using-the-operator/logs/",
	"title": "Logs",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/weblogic-kubernetes-operator/userguide/managing-domains/domain-lifecycle/shutdown/",
	"title": "Shutdown",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/weblogic-kubernetes-operator/userguide/managing-domains/domain-lifecycle/",
	"title": "Domain Lifecycle",
	"tags": [],
	"description": "",
	"content": " Chapter 4 Domain Lifecycle Lorem Ipsum.\n"
},
{
	"uri": "/weblogic-kubernetes-operator/userguide/managing-domains/",
	"title": "Managing Domains",
	"tags": [],
	"description": "",
	"content": " Chapter 3 Managing Domains Lorem Ipsum.\n"
},
{
	"uri": "/weblogic-kubernetes-operator/quickstart/install/",
	"title": "Install the operator and load balancer",
	"tags": [],
	"description": "",
	"content": " Grant the Helm service account the cluster-admin role. $ cat \u0026lt;\u0026lt;EOF | kubectl apply -f - apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: helm-user-cluster-admin-role roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: cluster-admin subjects: - kind: ServiceAccount name: default namespace: kube-system EOF  Create a Traefik (Ingress-based) load balancer. Use helm to install the Traefik load balancer. Use the values.yaml in the sample but set kubernetes.namespaces specifically.\n$ helm install stable/traefik \\ --name traefik-operator \\ --namespace traefik \\ --values kubernetes/samples/charts/traefik/values.yaml \\ --set \u0026quot;kubernetes.namespaces={traefik}\u0026quot; \\ --wait  Install the operator. a. Create a namespace for the operator:\n$ kubectl create namespace sample-weblogic-operator-ns  b. Create a service account for the operator in the operator\u0026rsquo;s namespace:\n$ kubectl create serviceaccount -n sample-weblogic-operator-ns sample-weblogic-operator-sa  c. Use helm to install and start the operator from the directory you just cloned:\n$ helm install kubernetes/charts/weblogic-operator \\ --name sample-weblogic-operator \\ --namespace sample-weblogic-operator-ns \\ --set image=oracle/weblogic-kubernetes-operator:2.0-rc2 \\ --set serviceAccount=sample-weblogic-operator-sa \\ --set \u0026quot;domainNamespaces={}\u0026quot; \\ --wait  d. Verify that the operator\u0026rsquo;s pod is running, by listing the pods in the operator\u0026rsquo;s namespace. You should see one for the operator.\n$ kubectl get pods -n sample-weblogic-operator-ns  e. Verify that the operator is up and running by viewing the operator pod\u0026rsquo;s log:\n$ kubectl logs -n sample-weblogic-operator-ns -c weblogic-operator deployments/weblogic-operator  "
},
{
	"uri": "/weblogic-kubernetes-operator/developerguide/",
	"title": "Developer Guide",
	"tags": [],
	"description": "",
	"content": " Chapter 4 Developer Guide This guide provides information for developers who wish to understand or contribute to the code.\n"
},
{
	"uri": "/weblogic-kubernetes-operator/userguide/introduction/overview/",
	"title": "Overview",
	"tags": [],
	"description": "",
	"content": "The information in the following sections is organized in the order that you would most likely need to use it. If you want to set up an operator and use it to create and manage WebLogic domains, you should follow the User Guide sections from top to bottom, and the necessary information will be presented in the correct order.\n"
},
{
	"uri": "/weblogic-kubernetes-operator/userguide/managing-domains/accessing-the-domain/",
	"title": "Accessing the Domain",
	"tags": [],
	"description": "",
	"content": " Chapter 5 Accessing the Domain Lorem Ipsum.\n"
},
{
	"uri": "/weblogic-kubernetes-operator/samples/simple/ingress/",
	"title": "Ingress",
	"tags": [],
	"description": "",
	"content": " Chapter 5 Ingress Lorem Ipsum.\n"
},
{
	"uri": "/weblogic-kubernetes-operator/developerguide/coding-standards/",
	"title": "Coding Standards",
	"tags": [],
	"description": "",
	"content": " This project has adopted the following coding standards:\n Code will be formated using Oracle / WebLogic standards, which are identical to the Google Java Style. Javadoc must be provided for all public packages, classes, and methods, and must include all parameters and returns. Javadoc is not required for methods that override or implement methods that are already documented. All non-trivial methods should include LOGGER.entering() and LOGGER.exiting() calls. The LOGGER.exiting() call should include the value that is going to be returned from the method, unless that value includes a credential or other sensitive information. All logged messages must be internationalized using the resource bundle src/main/resources/Operator.properties and using a key itemized in src/main/java/oracle/kubernetes/operator/logging/MessageKeys.java. After operator initialization, all operator work must be implemented using the asynchronous call model (described below). In particular, worker threads must not use sleep() or IO or lock-based blocking methods.  Code formatting plugins The following IDE plugins are available to assist with following the code formatting standards\nIntelliJ An IntelliJ plugin is available from the plugin repository.\nThe plugin will be enabled by default. To disable it in the current project, go to File \u0026gt; Settings... \u0026gt; google-java-format Settings (or IntelliJ IDEA \u0026gt; Preferences... \u0026gt; Other Settings \u0026gt; google-java-format Settings on macOS) and uncheck the \u0026ldquo;Enable google-java-format\u0026rdquo; checkbox.\nTo disable it by default in new projects, use File \u0026gt; Other Settings \u0026gt; Default Settings....\nWhen enabled, it will replace the normal \u0026ldquo;Reformat Code\u0026rdquo; action, which can be triggered from the \u0026ldquo;Code\u0026rdquo; menu or with the Ctrl-Alt-L (by default) keyboard shortcut.\nThe import ordering is not handled by this plugin, unfortunately. To fix the import order, download the IntelliJ Java Google Style file and import it into File→Settings→Editor→Code Style.\nEclipse An Eclipse plugin can be downloaded from the releases page. Drop it into the Eclipse drop-ins folder to activate the plugin.\nThe plugin adds a google-java-format formatter implementation that can be configured in Eclipse \u0026gt; Preferences \u0026gt; Java \u0026gt; Code Style \u0026gt; Formatter \u0026gt; Formatter Implementation.\n"
},
{
	"uri": "/weblogic-kubernetes-operator/reference/",
	"title": "Reference",
	"tags": [],
	"description": "",
	"content": " Chapter 5 Reference This section contains links to reference documentation.\n"
},
{
	"uri": "/weblogic-kubernetes-operator/quickstart/prepare/",
	"title": "Prepare for a domain",
	"tags": [],
	"description": "",
	"content": "a. Create a namespace that can host one or more domains:\n$ kubectl create namespace sample-domain1-ns  b. Use helm to configure the operator to manage domains in this namespace:\n$ helm upgrade \\ --reuse-values \\ --set \u0026quot;domainNamespaces={sample-domain1-ns}\u0026quot; \\ --wait \\ sample-weblogic-operator \\ kubernetes/charts/weblogic-operator  c. Configure Traefik to manage Ingresses created in this namespace:\n$ helm upgrade \\ --reuse-values \\ --set \u0026quot;kubernetes.namespaces={traefik,sample-domain1-ns}\u0026quot; \\ --wait \\ traefik-operator \\ stable/traefik  "
},
{
	"uri": "/weblogic-kubernetes-operator/userguide/managing-domains/ingress/",
	"title": "Ingress",
	"tags": [],
	"description": "",
	"content": " Chapter 6 Ingress Lorem Ipsum.\n"
},
{
	"uri": "/weblogic-kubernetes-operator/security/",
	"title": "Security",
	"tags": [],
	"description": "",
	"content": " Chapter 6 Security Lorem Ipsum.\n"
},
{
	"uri": "/weblogic-kubernetes-operator/samples/simple/elastic-stack/",
	"title": "Elastic Stack",
	"tags": [],
	"description": "",
	"content": " Chapter 6 Elastic Stack Lorem Ipsum.\n"
},
{
	"uri": "/weblogic-kubernetes-operator/developerguide/code-structure/",
	"title": "Code Structure",
	"tags": [],
	"description": "",
	"content": " This project has the following directory structure:\n docs: Generated Javadoc and Swagger integration-tests: Integration test suite json-schema: Java model to JSON schema generator json-schema-maven-plugin: Maven plugin for schema generator kubernetes/charts: Helm charts kubernetes/samples: All samples, including for WebLogic domain creation model: Domain resource Java model operator: Operator runtime site: This documentation src/scripts: Scripts operator injects into WebLogic server instance Pods swagger: Swagger files for the Kubernetes API server and domain resource  Watch package The Watch API in the Kubernetes Java client provides a watch capability across a specific list of resources for a limited amount of time. As such, it is not ideally suited for our use case, where a continuous stream of watches is desired, with watch events generated in real time. The watch-wrapper in this repository extends the default Watch API to provide a continuous stream of watch events until the stream is specifically closed. It also provides resourceVersion tracking to exclude events that have already been seen. The watch-wrapper provides callbacks so events, as they occur, can trigger actions.\n"
},
{
	"uri": "/weblogic-kubernetes-operator/quickstart/create-domain/",
	"title": "Create a domain",
	"tags": [],
	"description": "",
	"content": "a. Create a Kubernetes secret containing the username and password for the domain using the create-weblogic-credentials script:\n$ kubernetes/samples/scripts/create-weblogic-domain-credentials/create-weblogic-credentials.sh \\ -u weblogic -p welcome1 -n sample-domain1-ns -d sample-domain1  The sample will create a secret named domainUID-weblogic-credentials where the domainUID is replaced with the value you provided. For example, the command above would create a secret named sample-domain1-weblogic-credentials.\nb. Create a new image with a domain home by running the create-domain script. Follow the directions in the README file, including:\n Copying the sample kubernetes/samples/scripts/create-weblogic-domain/domain-home-in-image/create-domain-inputs.yaml file and updating your copy with the domainUID (sample-domain1), domain namespace (sample-domain1-ns), and the domainHomeImageBase (store/oracle/weblogic:12.2.1.3).\n Setting weblogicCredentialsSecretName to the name of the secret containing the WebLogic credentials, in this case, sample-domain1-weblogic-credentials.\n Leaving the image empty unless you need to tag the new image that the script builds to a different name.\n  If you set the domainHomeImageBuildPath property to ./docker-images/OracleWebLogic/samples/12213-domain-home-in-image-wdt, make sure that your JAVA_HOME is set to a Java JDK version 1.8 or later.\n\rFor example, assuming you named your copy my-inputs.yaml:\n$ cd kubernetes/samples/scripts/create-weblogic-domain/domain-home-in-image $ ./create-domain.sh -i my-inputs.yaml -o /some/output/directory -u weblogic -p welcome1 -e  You need to provide the WebLogic administration user name and password in the -u and -p options respectively, as shown in the example.\nWhen using this sample, the WebLogic Server credentials that you specify, in three separate places, must be consistent:\n The secret that you create for the credentials. The properties files in the sample project you choose to create the Docker image from. The parameters you supply to the create-domain.sh script.  \rIf you specify the -e option, the script will generate the Kubernetes YAML files and apply them to your cluster. If you omit the -e option, the script will just generate the YAML files, but will not take any action on your cluster.\nIf you run the sample from a machine that is remote to the Kubernetes cluster, and you need to push the new image to a registry that is local to the cluster, you need to do the following: * Set the image property in the inputs file to the target image name (including the registry hostname/port, and the tag if needed). * If you want Kubernetes to pull the image from a private registry, create a Kubernetes secret to hold your credentials and set the imagePullSecretName property in the inputs file to the name of the secret. Note that the secret needs to be in the same namespace as where you want to run the domain. * Run the create-domain.sh script without the -e option. * Push the image to the registry. * Run the following command to create the domain.\n$ kubectl apply -f /some/output/directory/weblogic-domains/sample-domain1/domain.yaml  c. Confirm that the operator started the servers for the domain: * Use kubectl to show that the domain resource was created:\n$ kubectl describe domain sample-domain1 -n sample-domain1-ns  After a short time, you will see the Administration Server and Managed Servers running.\n$ kubectl get pods -n sample-domain1-ns  You should also see all the Kubernetes services for the domain.\n$ kubectl get services -n sample-domain1-ns  d. Create an Ingress for the domain, in the domain namespace, by using the sample Helm chart:\n$ helm install kubernetes/samples/charts/ingress-per-domain \\ --name sample-domain1-ingress \\ --namespace sample-domain1-ns \\ --set wlsDomain.domainUID=sample-domain1 \\ --set traefik.hostname=sample-domain1.org  e. To confirm that the load balancer noticed the new Ingress and is successfully routing to the domain\u0026rsquo;s server pods, you can send a request to the URL for the \u0026ldquo;WebLogic ReadyApp framework\u0026rdquo; which will return a HTTP 200 status code, as shown in the example below. If you used the host-based routing Ingress sample, you will need to provide the hostname in the -H option.\nSubstitute the Node IP address of the worker node for your.server.com. You can find it by running:\n$ kubectl get po -n sample-domain1-ns -o wide TODO SOMETHING MISSING $ curl -v -H 'host: sample-domain1.org' http://your.server.com:30305/weblogic/ready * About to connect() to your.server.com port 30305 (#0) * Trying 10.196.1.64... * Connected to your.server.com (10.196.1.64) port 30305 (#0) \u0026gt; GET /weblogic/ HTTP/1.1 \u0026gt; User-Agent: curl/7.29.0 \u0026gt; Accept: */* \u0026gt; host: domain1.org \u0026gt; \u0026lt; HTTP/1.1 200 OK \u0026lt; Content-Length: 0 \u0026lt; Date: Thu, 20 Dec 2018 14:52:22 GMT \u0026lt; Vary: Accept-Encoding \u0026lt; * Connection #0 to host your.server.com left intact  Depending on where your Kubernetes cluster is running, you may need to open firewall ports or update security lists to allow ingress to this port.\n\rf. To access the WLS Administration Console, edit the my-inputs.yaml file (assuming that you named your copy my-inputs.yaml) to set exposedAdminNodePort: true. Open a browser to http://your.server.com:30701. As in the previous step, substitute the Node IP address of the worker node for your.server.com.\n"
},
{
	"uri": "/weblogic-kubernetes-operator/developerguide/asynchronous-call-model/",
	"title": "Asynchronous Call Model",
	"tags": [],
	"description": "",
	"content": " Our expectation is that customers will task the operator with managing hundreds of WebLogic domains across dozens of Kubernetes namespaces. Therefore, we have designed the operator with an efficient user-level threads pattern. We\u0026rsquo;ve used that pattern to implement an asynchronous call model for Kubernetes API requests. This call model has built-in support for timeouts, retries with exponential back-off, and lists that exceed the requested maximum size using the continuance functionality.\nUser-Level Thread Pattern The user-level thread pattern is implemented by the classes in the oracle.kubernetes.operator.work package.\n Engine: The executor service and factory for Fibers. Fiber: The user-level thread. Fibers represent the execution of a single processing flow through a series of Steps. Fibers may be suspended and later resumed, and do not consume a Thread while suspended. Step: Individual CPU-bound activity in a processing flow. Packet: Context of the processing flow. NextAction: Used by a Step when it returns control to the Fiber to indicate what should happen next. Common \u0026lsquo;next actions\u0026rsquo; are to execute another Step or to suspend the Fiber. Component: Provider of SPI\u0026rsquo;s that may be useful to the processing flow. Container: Represents the containing environment and is a Component.  Each Step has a reference to the next Step in the processing flow; however, Steps are not required to indicate that the next Step be invoked by the Fiber when the Step returns a NextAction to the Fiber. This leads to common use cases where Fibers invoke a series of Steps that are linked by the \u0026lsquo;is-next\u0026rsquo; relationship, but just as commonly, use cases where the Fiber will invoke sets of Steps along a detour before returning to the normal flow.\nIn this sample, the caller creates an Engine, Fiber, linked set of Step instances, and Packet. The Fiber is then started. The Engine would typically be a singleton, since it\u0026rsquo;s backed by a ScheduledExecutorService. The Packet would also typically be pre-loaded with values that the Steps would use in their apply() methods.\nstatic class SomeClass { public static void main(String[] args) { Engine engine = new Engine(\u0026quot;worker-pool\u0026quot;); Fiber fiber = engine.createFiber(); Step step = new StepOne(new StepTwo(new StepThree(null))); Packet packet = new Packet(); fiber.start( step, packet, new CompletionCallback() { @Override public void onCompletion(Packet packet) { // Fiber has completed successfully } @Override public void onThrowable(Packet packet, Throwable throwable) { // Fiber processing was terminated with an exception } }); } }  Steps must not invoke sleep or blocking calls from within apply(). This prevents the worker threads from serving other Fibers. Instead, use asynchronous calls and the Fiber suspend/resume pattern. Step provides a method, doDelay(), which creates a NextAction to drive Fiber suspend/resume that is a better option than sleep precisely because the worker thread can serve other Fibers during the delay. For asynchronous IO or similar patterns, suspend the Fiber. In the callback as the Fiber suspends, initiate the asynchronous call. Finally, when the call completes, resume the Fiber. The suspend/resume functionality handles the case where resumed before the suspending callback completes.\nIn this sample, the step uses asynchronous file IO and the suspend/resume Fiber pattern.\nstatic class StepTwo extends Step { public StepTwo(Step next) { super(next); } @Override public NextAction apply(Packet packet) { return doSuspend((fiber) -\u0026gt; { // The Fiber is now suspended // Start the asynchronous call try { Path path = Paths.get(URI.create(this.getClass().getResource(\u0026quot;/somefile.dat\u0026quot;).toString())); AsynchronousFileChannel fileChannel = AsynchronousFileChannel.open(path, StandardOpenOption.READ); ByteBuffer buffer = ByteBuffer.allocate(1024); fileChannel.read(buffer, 0, buffer, new CompletionHandler\u0026lt;Integer, ByteBuffer\u0026gt;() { @Override void completed(Integer result, ByteBuffer attachment) { // Store data in Packet and resume Fiber packet.put(\u0026quot;DATA_SIZE_READ\u0026quot;, result); packet.put(\u0026quot;DATA_FROM_SOMEFILE\u0026quot;, attachment); fiber.resume(packet); } @Override public void failed(Throwable exc, ByteBuffer attachment) { // log exc completed(0, null); } }); } catch (IOException e) { // log exception // If not resumed here, Fiber will never be resumed } }); } }  Call Builder Pattern The asynchronous call model is implemented by classes in the oracle.kubernetes.operator.helpers package, including CallBuilder and ResponseStep. The model is based on the Fiber suspend/resume pattern described above. CallBuilder provides many methods having names ending with \u0026ldquo;Async\u0026rdquo;, such as listPodAsync() or deleteServiceAsync(). These methods return a Step that can be returned as part of a NextAction. When creating these Steps, the developer must provide a ResponseStep. Only ResponseStep.onSuccess() must be implemented; however, it is often useful to override onFailure() as Kubernetes treats 404 (Not Found) as a failure.\nIn this sample, the developer is using the pattern to list pods from the default namespace that are labeled as part of cluster-1.\nstatic class StepOne extends Step { public StepOne(Step next) { super(next); } @Override public NextAction apply(Packet packet) { String namespace = \u0026quot;default\u0026quot;; Step step = CallBuilder.create().with($ -\u0026gt; { $.labelSelector = \u0026quot;weblogic.clusterName=cluster-1\u0026quot;; $.limit = 50; $.timeoutSeconds = 30; }).listPodAsync(namespace, new ResponseStep\u0026lt;V1PodList\u0026gt;(next) { @Override public NextAction onFailure(Packet packet, ApiException e, int statusCode, Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; responseHeaders) { if (statusCode == CallBuilder.NOT_FOUND) { return onSuccess(packet, null, statusCode, responseHeaders); } return super.onFailure(packet, e, statusCode, responseHeaders); } @Override NextAction onSuccess(Packet packet, V1PodList result, int statusCode, Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; responseHeaders) { // do something with the result Pod, if not null return doNext(packet); } }); return doNext(step, packet); } }  Notice that the required parameters, such as namespace, are method arguments, but optional parameters are designated using a simplified builder pattern using with() and a lambda.\nThe default behavior of onFailure() will retry with an exponential backoff the request on status codes 429 (TooManyRequests), 500 (InternalServerError), 503 (ServiceUnavailable), 504 (ServerTimeout) or a simple timeout with no response from the server.\nIf the server responds with status code 409 (Conflict), then this indicates an optimistic locking failure. Common use cases are that the code read a Kubernetes object in one asynchronous step, modified the object, and attempted to replace the object in another asynchronous step; however, another activity replaced that same object in the interim. In this case, retrying the request would give the same result. Therefore, developers may provide an \u0026ldquo;on conflict\u0026rdquo; step when calling super.onFailure(). The conflict step will be invoked after an exponential backoff delay. In this example, that conflict step should be the step that reads the existing Kubernetes object.\n"
},
{
	"uri": "/weblogic-kubernetes-operator/userguide/managing-domains/integrations/",
	"title": "Integrations",
	"tags": [],
	"description": "",
	"content": " Chapter 7 Integrations Lorem Ipsum.\n"
},
{
	"uri": "/weblogic-kubernetes-operator/faq/",
	"title": "Frequently Asked Questions",
	"tags": [],
	"description": "",
	"content": " Chapter 7 Frequently Asked Questions This section provides answers to frequently asked questions.\n"
},
{
	"uri": "/weblogic-kubernetes-operator/quickstart/cleanup/",
	"title": "Cleaning up",
	"tags": [],
	"description": "",
	"content": " Remove the domain. a. Remove the domain\u0026rsquo;s Ingress by using helm:\n$ helm delete --purge sample-domain1-ingress  b. Remove the domain resources by using the sample delete-weblogic-domain-resources script.\n$ kubernetes/samples/scripts/delete-domain/delete-weblogic-domain-resources.sh -d sample-domain1  c. Use kubectl to confirm that the server pods and domain resource are gone:\n$ kubectl get pods -n sample-domain1-ns $ kubectl get domains -n sample-domain1-ns  Remove the domain namespace. a. Configure the Traefik load balancer to stop managing the Ingresses in the domain namespace:\n$ helm upgrade \\ --reuse-values \\ --set \u0026quot;kubernetes.namespaces={traefik}\u0026quot; \\ --wait \\ traefik-operator \\ stable/traefik  b. Configure the operator to stop managing the domain:\n$ helm upgrade \\ --reuse-values \\ --set \u0026quot;domainNamespaces={}\u0026quot; \\ --wait \\ sample-weblogic-operator \\ kubernetes/charts/weblogic-operator  c. Delete the domain namespace:\n$ kubectl delete namespace sample-domain1-ns  Remove the operator. a. Remove the operator:\n$ helm delete --purge sample-weblogic-operator  b. Remove the operator\u0026rsquo;s namespace:\n$ kubectl delete namespace sample-weblogic-operator-ns  Remove the load balancer. a. Remove the Traefik load balancer:\n$ helm delete --purge traefik-operator  b. Remove the Traefik namespace:\n$ kubectl delete namespace traefik  "
},
{
	"uri": "/weblogic-kubernetes-operator/developerguide/domain-processing/",
	"title": "Domain Processing",
	"tags": [],
	"description": "",
	"content": "When the operator starts, it lists all existing Domain resources and processes these domains to create the necessary Kubernetes resources, such as Pods and Services, if they don\u0026rsquo;t already exist. This initialization also includes looking for any stranded resources that, while created by the operator, no longer correlate with a Domain resource.\nAfter this, the operator starts watches for changes to Domain resources and any changes to other resources created by the operator. When a watch event is received, the operator processes the modified Domain resource to again bring the runtime presence in to alignment with the desired state.\nThe operator ensures that at most one Fiber is running for any given Domain. For instance, if the customer modifies a Domain resource to trigger a rolling restart, then the operator will create a Fiber to process this activity. However, if while the rolling restart is in process, the customer makes another change to the Domain resource, such as to increase the replicas field for a cluster, then the operator will cancel the in-flight Fiber and replace it with a new Fiber. This replacement processing must be able to handle taking over for the cancelled work regardless of where the earlier processing may have been in its flow. Therefore, domain processing always starts at the beginning of the \u0026ldquo;make right\u0026rdquo; flow without any state other than the current Domain resource.\nFinally, the operator periodically lists all Domains and rechecks them. This is a backstop against the possibility that a watch event is missed, such as because of a temporary network outage. Recheck activities will not interrupt already running processes for a given Domain.\n"
},
{
	"uri": "/weblogic-kubernetes-operator/developerguide/backwards-compatibility/",
	"title": "Backwards Compatibility",
	"tags": [],
	"description": "",
	"content": "Starting with the 2.0 release, future operator releases must be backward compatible with respect to the domain resource schema, operator Helm chart input values, configuration overrides template, Kubernetes resources created by the operator Helm chart, Kubernetes resources created by the operator, and the operator REST interface. We will maintain compatibility for three releases, except in the case of a clearly communicated deprecated feature, which will be maintained for one release after a replacement is available.\n"
},
{
	"uri": "/weblogic-kubernetes-operator/security/secrets/",
	"title": "Secrets",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/weblogic-kubernetes-operator/security/encryption/",
	"title": "Encryption",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/weblogic-kubernetes-operator/security/certificates/",
	"title": "Certificates",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/weblogic-kubernetes-operator/security/service-accounts/",
	"title": "Service Accounts",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/weblogic-kubernetes-operator/userguide/managing-domains/integrations/exporting-logs/elastic-stack/",
	"title": "Elastic Stack",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/weblogic-kubernetes-operator/userguide/managing-domains/integrations/exporting-logs/log-exporter/",
	"title": "Log Exporter",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/weblogic-kubernetes-operator/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " Oracle WebLogic Server Kubernetes Operator Oracle is finding ways for organizations using WebLogic Server to run important workloads, to move those workloads into the cloud. By certifying on industry standards, such as Docker and Kubernetes, WebLogic now runs in a cloud neutral infrastructure. In addition, we\u0026rsquo;ve provided an open-source Oracle WebLogic Server Kubernetes Operator (the “operator”) which has several key features to assist you with deploying and managing WebLogic domains in a Kubernetes environment. You can:\n Create WebLogic domains in a Kubernetes persistent volume. This persistent volume can reside in an NFS file system or other Kubernetes volume types. Create a WebLogic domain in a Docker image. Override certain aspects of the WebLogic domain configuration. Define WebLogic domains as a Kubernetes resource (using a Kubernetes custom resource definition). Start servers based on declarative startup parameters and desired states. Manage WebLogic configured or dynamic clusters. Expose the WebLogic Server Administration Console outside the Kubernetes cluster, if desired. Expose T3 channels outside the Kubernetes domain, if desired. Expose HTTP paths on a WebLogic domain outside the Kubernetes domain with load balancing and update the load balancer when Managed Servers in the WebLogic domain are started or stopped. Scale WebLogic domains by starting and stopping Managed Servers on demand, or by integrating with a REST API to initiate scaling based on WLDF, Prometheus, Grafana, or other rules. Publish operator and WebLogic Server logs into Elasticsearch and interact with them in Kibana.  The fastest way to experience the operator is to follow the Quick Start guide, or you can peruse our documentation, read our blogs, or try out the samples.\n+ The current release of the operator is 2.0-rc2, a release candidate for our 2.0 release. + This release candidate was published on Jan. 16, 2019. + We expect to publish the final 2.0 release later in January, 2019. + We expect that there will be some minor changes to documentation and samples in the final 2.0 release. + However, this release candidate is suitable for testing and early adopters.  Known issues    Issue Description     #726 Clusters only support default channel.    Operator version 1.1 Documentation for the 1.1 release of the operator is available here.\nBackward compatibility guidelines The 2.0 release introduces some breaking changes and does not maintain compatibility with previous releases.\nStarting with the 2.0 release, future operator releases are intended to be backward compatible with respect to the domain resource schema, operator Helm chart input values, configuration overrides template, Kubernetes resources created by the operator Helm chart, Kubernetes resources created by the operator, and the operator REST interface. We intend to maintain compatibility for three releases, except in the case of a clearly communicated deprecated feature, which will be maintained for one release after a replacement is available.\nAbout this documentation This documentation includes sections targeted to different audiences. To help you find what you are looking for more easily, please consult this table of contents:\n The Quick Start guide explains how to quickly get the operator running, using the defaults, nothing special. The User guide contains detailed usage information, including how to install and configure the operator, and how to use it to create and manage WebLogic domains.\n The Samples provide detailed example code and instructions that show you how to perform various tasks related to the operator. The Developer guide provides details for people who want to understand how the operator is built, tested, and so on. Those who wish to contribute to the operator code will find useful information here. This section also includes API documentation (Javadoc) and Swagger/OpenAPI documentation for the REST APIs. The Contributing section provides information about contribution requirements.  User guide The User guide provides detailed information about all aspects of using the operator including:\n Installing and configuring the operator. Using the operator to create and manage WebLogic domains. Manually creating WebLogic domains to be managed by the operator. Scaling WebLogic clusters. Configuring Kubernetes load balancers. Configuring Elasticsearch and Kibana to access the operator\u0026rsquo;s log files. Shutting down domains. Removing/deleting domains. And much more!  Samples Please refer to our samples for information about the available sample code.\nNeed more help? Have a suggestion? Come and say, \u0026ldquo;Hello!\u0026rdquo; We have a public Slack channel where you can get in touch with us to ask questions about using the operator or give us feedback or suggestions about what features and improvements you would like to see. We would love to hear from you. To join our channel, please visit this site to get an invitation. The invitation email will include details of how to access our Slack workspace. After you are logged in, please come to #operator and say, \u0026ldquo;hello!\u0026rdquo;\nRecent changes See Recent changes for changes to the operator, including any backward incompatible changes.\nDeveloper guide Developers interested in this project are encouraged to read the Developer guide to learn how to build the project, run tests, and so on. The Developer guide also provides details about the structure of the code, coding standards, and the Asynchronous Call facility used in the code to manage calls to the Kubernetes API.\nPlease take a look at our wish list to get an idea of the kind of features we would like to add to the operator. Maybe you will see something to which you would like to contribute!\nAPI documentation Documentation for APIs:\n The operator provides a REST API that you can use to obtain configuration information and to initiate scaling actions. For details about how to use the REST APIs, see Using the operator\u0026rsquo;s REST services.\n See the Swagger documentation for the operator\u0026rsquo;s REST interface.\n See the Javadoc for the operator.\n  Contributing to the operator Oracle welcomes contributions to this project from anyone. Contributions may be reporting an issue with the operator or submitting a pull request. Before embarking on significant development that may result in a large pull request, it is recommended that you create an issue and discuss the proposed changes with the existing developers first.\nIf you want to submit a pull request to fix a bug or enhance an existing feature, please first open an issue and link to that issue when you submit your pull request.\nIf you have any questions about a possible submission, feel free to open an issue too.\nContributing to the Oracle WebLogic Server Kubernetes Operator repository Pull requests can be made under The Oracle Contributor Agreement (OCA), which is available at https://www.oracle.com/technetwork/community/oca-486395.html.\nFor pull requests to be accepted, the bottom of the commit message must have the following line, using the contributor’s name and e-mail address as it appears in the OCA Signatories list.\nSigned-off-by: Your Name \u0026lt;you@example.org\u0026gt;  This can be automatically added to pull requests by committing with:\ngit commit --signoff  Only pull requests from committers that can be verified as having signed the OCA can be accepted.\nPull request process  Fork the repository. Create a branch in your fork to implement the changes. We recommend using the issue number as part of your branch name, for example, 1234-fixes. Ensure that any documentation is updated with the changes that are required by your fix. Ensure that any samples are updated if the base image has been changed. Submit the pull request. Do not leave the pull request blank. Explain exactly what your changes are meant to do and provide simple steps on how to validate your changes. Ensure that you reference the issue you created as well. We will assign the pull request to 2-3 people for review before it is merged.  Introducing a new dependency Please be aware that pull requests that seek to introduce a new dependency will be subject to additional review. In general, contributors should avoid dependencies with incompatible licenses, and should try to use recent versions of dependencies. Standard security vulnerability checklists will be consulted before accepting a new dependency. Dependencies on closed-source code, including WebLogic Server, will most likely be rejected.\nUse Helm Chart from Github chart repository Add this repo to Helm installation:\n$ helm repo add weblogic-operator https://oracle.github.io/weblogic-kubernetes-operator/charts  Verify repository was added correctly:\n$ helm repo list NAME URL weblogic-operator https://oracle.github.io/weblogic-kubernetes-operator/charts  Update with latest information about charts from chart repositories:\n$ helm repo update  Install Operator from the repo:\n$ helm install helm install weblogic-operator/weblogic-operator --name weblogic-operator  "
},
{
	"uri": "/weblogic-kubernetes-operator/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/weblogic-kubernetes-operator/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]